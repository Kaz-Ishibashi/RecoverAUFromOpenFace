# debug_cp1_v2.py
# Debug CP1 (Landmarks) - Deep Dive into FrameID mapping
# CP1（ランドマーク） - フレームIDマッピングの詳細分析

import pandas as pd
import numpy as np

# Load dumps
df_gt = pd.read_csv('dump_openface.csv', header=None, names=['FrameID','CP','Idx','Val'])
df_tg = pd.read_csv('dump_recover.csv', header=None, names=['FrameID','CP','Idx','Val'])

print("=" * 70)
print("CP1 FrameID Mapping Analysis")
print("=" * 70)

cp1_gt = df_gt[df_gt['CP']=='CP1'].sort_values(['FrameID', 'Idx'])
cp1_tg = df_tg[df_tg['CP']=='CP1'].sort_values(['FrameID', 'Idx'])

print(f"GT FrameID range: {cp1_gt['FrameID'].min()} - {cp1_gt['FrameID'].max()}")
print(f"TG FrameID range: {cp1_tg['FrameID'].min()} - {cp1_tg['FrameID'].max()}")

# The key insight:
# GT uses frames_tracking which starts at 0 and is logged AFTER increment
# In OpenFace: frames_tracking++; DUMP_MAT(frames_tracking, ...)
# So GT Frame 1 = processing of Frame 0 data
#
# TG uses dump_frame_id = i + 1
# So TG Frame 1 = processing of i=0 data
#
# They SHOULD match!

print("\n--- Let's check if GT Frame N == TG Frame N ---")

# Get first landmark value (Idx=0) for each frame
gt_frame_idx0 = cp1_gt[cp1_gt['Idx']==0][['FrameID', 'Val']].set_index('FrameID')
tg_frame_idx0 = cp1_tg[cp1_tg['Idx']==0][['FrameID', 'Val']].set_index('FrameID')

# Compare
for frame_id in range(1, 6):
    gt_val = gt_frame_idx0.loc[frame_id, 'Val'] if frame_id in gt_frame_idx0.index else None
    tg_val = tg_frame_idx0.loc[frame_id, 'Val'] if frame_id in tg_frame_idx0.index else None
    
    if gt_val is not None and tg_val is not None:
        err = abs(gt_val - tg_val)
        print(f"Frame {frame_id}: GT={gt_val:.4f}, TG={tg_val:.4f}, Err={err:.4f}")

print("\n--- Now check GT Frame N vs TG Frame N (without offset) ---")
print("If GT dumps detected landmarks BEFORE writing to CSV,")
print("then GT might have different landmark values...")

# Load actual CSV
csv_df = pd.read_csv('samples/recover_au_test/test_bash1.csv')
csv_x0 = csv_df['x_0'].values

print("\n--- Compare CSV x_0 to both GT and TG ---")
for i in range(5):
    csv_val = csv_x0[i]
    # GT Frame i+1 corresponds to processing of input frame i (because frames_tracking++)
    gt_frame = i + 1  # GT increments before dump
    tg_frame = i + 1  # TG uses i+1 explicitly
    
    gt_val = gt_frame_idx0.loc[gt_frame, 'Val'] if gt_frame in gt_frame_idx0.index else None
    tg_val = tg_frame_idx0.loc[tg_frame, 'Val'] if tg_frame in tg_frame_idx0.index else None
    
    print(f"Input Frame {i}: CSV x_0={csv_val:.4f}")
    if gt_val is not None:
        print(f"  -> GT Frame {gt_frame}: {gt_val:.4f} (err={abs(csv_val - gt_val):.4f})")
    if tg_val is not None:
        print(f"  -> TG Frame {tg_frame}: {tg_val:.4f} (err={abs(csv_val - tg_val):.4f})")

print("\n" + "=" * 70)
print("CONCLUSION")
print("=" * 70)
print("""
The issue is that:
1. GT (OpenFace) dumps landmarks DIRECTLY from video detection (live)
2. TG (RecoverAU) reads landmarks from CSV file

These are DIFFERENT sources! OpenFace runs landmark detection each time
on the video, and the results may slightly differ from what's in the CSV.

The CSV was generated by a PREVIOUS run of FeatureExtraction.
But we're comparing against landmarks from the CURRENT run.

SOLUTION: RecoverAU should use the SAME landmarks that OpenFace uses.
But we can't - RecoverAU doesn't have the video, only the CSV.

ALTERNATIVE: For verification, ensure we compare the SAME DATA.
The CSV file was written by FeatureExtraction, so the landmarks in the
CSV ARE the same as what was detected. The issue is that OpenFace dumps
landmarks BEFORE they're saved to CSV (they should be the same).

Wait - OpenFace detects landmarks and both dumps them AND saves to CSV.
They should be identical. Let me check if OpenFace saves the same values...
""")
